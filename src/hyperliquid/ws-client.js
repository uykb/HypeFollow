const WebSocket = require('ws');
const config = require('config');
const EventEmitter = require('events');
const logger = require('../utils/logger');
const parsers = require('./parsers');
const axios = require('axios');
const binanceClient = require('../binance/api-client');
const orderMapper = require('../core/order-mapper');
const orderExecutor = require('../core/order-executor');

class HyperliquidWS extends EventEmitter {
  constructor() {
    super();
    this.wsUrl = config.get('hyperliquid.wsUrl');
    this.followedUsers = config.get('hyperliquid.followedUsers'); // Array of UIDs
    this.ws = null;
    this.pingInterval = null;
    
    // Reconnection settings
    this.reconnectAttempts = 0;
    this.baseReconnectDelay = 1000; // 1 second
    this.maxReconnectDelay = 30000; // 30 seconds
    this.isExplicitClose = false;
    this.reconnectTimer = null;
  }

  connect() {
    if (this.ws) {
      this.ws.removeAllListeners();
      this.ws.terminate();
    }

    this.ws = new WebSocket(this.wsUrl);

    this.ws.on('open', () => {
      logger.info('Connected to Hyperliquid WebSocket');
      this.reconnectAttempts = 0; // Reset attempts on successful connection
      this.isExplicitClose = false;
      this.subscribe();
      this.startHeartbeat();
      
      // Perform Initial Sync of Open Orders
      this.syncInitialOrders();
    });


    this.ws.on('message', (data) => {
      try {
        const message = JSON.parse(data);
        this.handleMessage(message);
      } catch (error) {
        logger.error('Error parsing WebSocket message', error);
      }
    });

    this.ws.on('close', () => {
      this.stopHeartbeat();
      if (this.isExplicitClose) {
         logger.info('Hyperliquid WebSocket closed explicitly.');
         return;
      }

      logger.warn('Hyperliquid WebSocket disconnected');
      this.scheduleReconnect();
    });

    this.ws.on('error', (error) => {
      logger.error('Hyperliquid WebSocket error', error);
      // 'close' event usually follows 'error', so we handle reconnect there
    });
  }

  scheduleReconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }

    // Exponential backoff: base * 2^attempts
    const delay = Math.min(
      this.baseReconnectDelay * Math.pow(2, this.reconnectAttempts),
      this.maxReconnectDelay
    );

    logger.info(`Reconnecting in ${delay}ms (Attempt ${this.reconnectAttempts + 1})...`);

    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      this.connect();
    }, delay);
  }

  close() {
    this.isExplicitClose = true;
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close();
    }
  }

  subscribe() {
    if (this.followedUsers.length === 0) {
      logger.warn('No users to follow configured');
      return;
    }

    this.followedUsers.forEach(user => {
      // 1. Subscribe to Order Updates (Limit Orders)
      const orderMsg = {
        method: "subscribe",
        subscription: {
          type: "orderUpdates",
          user: user
        }
      };
      this.ws.send(JSON.stringify(orderMsg));
      logger.info(`Subscribed to orderUpdates for user: ${user}`);

      // 2. Subscribe to User Fills (Market Trades)
      const fillMsg = {
        method: "subscribe",
        subscription: {
          type: "userFills",
          user: user
        }
      };
      this.ws.send(JSON.stringify(fillMsg));
      logger.info(`Subscribed to userFills for user: ${user}`);
    });
  }

  async syncInitialOrders() {
    if (this.followedUsers.length === 0) return;

    logger.info('Starting initial sync of open orders...');

    // 1. Fetch Binance Open Orders (Snapshot)
    let binanceOpenOrders = [];
    const binanceOrdersMap = new Map(); // Symbol -> Array of Orders
    const binanceOrderIdMap = new Set(); // Set of OrderIDs for quick existence check

    try {
      binanceOpenOrders = await binanceClient.client.futuresOpenOrders();
      
      binanceOpenOrders.forEach(bo => {
        // Index by Symbol for Recovery matching
        if (!binanceOrdersMap.has(bo.symbol)) {
          binanceOrdersMap.set(bo.symbol, []);
        }
        binanceOrdersMap.get(bo.symbol).push(bo);
        
        // Index by ID for Sync verification
        binanceOrderIdMap.add(bo.orderId.toString());
      });
      
      logger.info(`Fetched ${binanceOpenOrders.length} active Binance orders for sync reconciliation.`);
    } catch (err) {
      logger.warn('Failed to fetch Binance open orders. Sync/Pruning will be limited.', err);
    }

    for (const user of this.followedUsers) {
      try {
        const response = await axios.post('https://api.hyperliquid.xyz/info', {
          type: "openOrders",
          user: user
        });

        const hlOpenOrders = response.data;
        const hlOrderIds = new Set();

        if (Array.isArray(hlOpenOrders)) {
          logger.info(`Found ${hlOpenOrders.length} existing open orders for ${user}. Syncing...`);
          
          // --- Phase 1: Sync HL -> Binance (Create / Verify) ---
          for (const order of hlOpenOrders) {
            hlOrderIds.add(order.oid.toString()); // Track for Pruning Phase

            // Standardize
            const standardizedOrder = {
              type: 'order',
              status: 'open',
              coin: order.coin,
              side: order.side,
              limitPx: order.limitPx,
              sz: order.sz,
              oid: order.oid,
              timestamp: order.timestamp,
              userAddress: user
            };

            // A. Check Existing Mapping
            const existingMapping = await orderMapper.getBinanceOrder(order.oid);
            
            if (existingMapping) {
              // We have a mapping. Check if the Binance Order is ACTUALLY active.
              if (binanceOrderIdMap.has(existingMapping.orderId.toString())) {
                // Perfect Sync: Mapped AND Active on Binance.
                // DO NOT EMIT. This prevents duplicates definitively.
                logger.debug(`[Sync] Order ${order.oid} already synced and active on Binance (${existingMapping.orderId}). Skipping.`);
                continue;
              } else {
                // Mapping exists, but Binance Order is MISSING from OpenOrders.
                // This means it was Filled or Canceled on Binance, but HL still has it Open.
                // We should probably allow re-creation (Emit), or treat as Orphan drift.
                // Given the user wants "Copy", if HL has it open, we should probably have it open.
                // So we fall through to Emit.
                logger.info(`[Sync] Order ${order.oid} mapped but not found in Binance OpenOrders. Retrying sync (creating new)...`);
                // Clean old mapping to allow new creation logic to run cleanly if needed
                await orderMapper.deleteMapping(order.oid); 
              }
            }

            // B. Recovery Check (If no valid mapping)
            const symbol = binanceClient.getBinanceSymbol(order.coin);
            const candidates = binanceOrdersMap.get(symbol) || [];

            if (candidates.length > 0) {
              const hlPriceFormatted = binanceClient.roundPrice(order.coin, order.limitPx);
              const binanceSide = order.side === 'B' ? 'BUY' : 'SELL';

              const matchIndex = candidates.findIndex(bo => {
                const priceDiff = Math.abs(parseFloat(bo.price) - parseFloat(hlPriceFormatted));
                // Allow small tolerance for floating point or rounding differences
                // e.g. 0.0001 or 0.1% of price? 
                // Using 0.0001 absolute tolerance for now, assuming similar precision.
                // Or better: check if priceDiff / price < 0.0001 (0.01%)
                const isPriceMatch = priceDiff < 0.0001 || (parseFloat(bo.price) > 0 && priceDiff / parseFloat(bo.price) < 0.0001);
                
                return bo.side === binanceSide && isPriceMatch;
              });

              if (matchIndex !== -1) {
                const matchedOrder = candidates[matchIndex];
                candidates.splice(matchIndex, 1); // Consume candidate

                logger.info(`[Sync] Recovered mapping: HL ${order.oid} <-> Binance ${matchedOrder.orderId}`);

                await orderMapper.saveMapping(order.oid, matchedOrder.orderId, symbol);
                await consistencyEngine.markOrderProcessed(order.oid, {
                  type: 'limit-recovered',
                  coin: order.coin,
                  restored: true,
                  binanceOrderId: matchedOrder.orderId,
                  recoveredAt: Date.now()
                });

                // Remove from map to prevent Pruning later (though Pruning checks Redis, so it's fine)
                continue; // Skip Emit
              } else {
                 logger.debug(`[Sync] No match found for HL ${order.oid} (${order.coin} ${order.side} ${hlPriceFormatted}). Candidates: ${candidates.length}`);
              }
            }
            
            // C. Create New
            logger.info(`[Sync] Processing NEW order for HL ${order.oid}`);
            try {
              await orderExecutor.executeLimitOrder(standardizedOrder);
            } catch (err) {
              logger.error(`[Sync] Failed to process initial order ${order.oid}`, err);
            }
            // Small delay to avoid rate limits, but now it's sequential
            await new Promise(resolve => setTimeout(resolve, 100));
          }

          // --- Phase 2: Prune Binance -> HL (Cancel Zombie Orders) ---
          // Iterate all Binance Open Orders. If they map to an HL Order that is NOT in hlOrderIds, Cancel them.
          
          for (const bOrder of binanceOpenOrders) {
            // Check if this Binance Order is a "Follow" order (has mapping)
            const mappedHlOid = await orderMapper.getHyperliquidOrder(bOrder.orderId);
            
            if (mappedHlOid) {
              // It is a Follow order.
              // Check if the Master Order still exists
              if (!hlOrderIds.has(mappedHlOid.toString())) {
                logger.info(`[Sync] Pruning Zombie Binance Order ${bOrder.orderId} (HL ${mappedHlOid} no longer open).`);
                
                try {
                  await binanceClient.cancelOrder(bOrder.symbol, bOrder.orderId);
                  await orderMapper.deleteMapping(mappedHlOid);
                } catch (err) {
                  logger.warn(`[Sync] Failed to prune order ${bOrder.orderId}`, err);
                }
                
                await new Promise(resolve => setTimeout(resolve, 50));
              }
            }
          }

        } else {
          logger.info(`No existing open orders found for ${user}.`);
        }
      } catch (error) {
        logger.error(`Failed to fetch initial orders for ${user}`, error);
      }
    }
  }

  handleMessage(message) {
    const { channel, data } = message;

    if (channel === 'orderUpdates') {
      logger.debug('WS: Received orderUpdates', { data }); // Detailed log
      const order = parsers.parseOrderUpdate(data);
      if (order) {
        // Fallback for userAddress if missing (MVP assumption: single user)
        if (!order.userAddress && this.followedUsers.length > 0) {
           order.userAddress = this.followedUsers[0];
        }
        
        logger.info(`WS: Parsed order event: ${order.status} ${order.coin} ${order.oid}`);
        this.emit('order', order);
      } else {
        logger.debug('WS: parseOrderUpdate returned null');
      }
    } else if (channel === 'userFills') {
      const fills = parsers.parseUserFills(data);
      if (fills && fills.length > 0) {
        fills.forEach(fill => {
          this.emit('fill', fill);
        });
      }
    }
  }

  startHeartbeat() {
    this.pingInterval = setInterval(() => {
      if (this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ method: "ping" }));
      }
    }, 30000);
  }

  stopHeartbeat() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
  }
}

module.exports = new HyperliquidWS();
